#!/usr/bin/env python
import argparse
import copy
import glob
import json
import multiprocessing
import os
import re
import shutil
import yaml
import platform

from colorama import Fore, Style, init

# Initialize colorama
init()

# Colors
class colors:
    if platform.system() == 'Windows':
        OKBLUE = Fore.BLUE
        OKCYAN = Fore.CYAN
        OKGREEN = Fore.GREEN
        WARNING = Fore.YELLOW
        FAIL = Fore.RED
        RESET = Style.RESET_ALL
        BOLD = Style.BRIGHT
    else:
        OKBLUE = '\033[94m'
        OKCYAN = '\033[96m'
        OKGREEN = '\033[92m'
        WARNING = '\033[93m'
        FAIL = '\033[91m'
        RESET = '\033[0m'
        BOLD = '\033[1m'

# Generate message
def message(type, color, message):
    return colors.BOLD + 'smake: ' + color + type + ': ' + colors.RESET + message

# Assert that a file exists
def assert_file(file_path):
    if not os.path.exists(file_path):
        msg = 'file ' + file_path + ' does not exist'
        print(message('fatal error', colors.FAIL, msg))
        exit(-1)

# Read all .smake files from this directory or any subdirectory
smake_files = []
for root, dirs, files in os.walk('.'):
    path = root.split(os.sep)
    for file in files:
        if file.endswith('.smake'):
            smake_file = os.path.join(root, file)
            smake_files.append(smake_file)

print(smake_files)

file = open(smake_files[1], 'r')
content = file.read()

# Parsing
from pyparsing import *

lparen = Literal('(').suppress()
rparen = Literal(')').suppress()
equals = Literal('=').suppress()
colon = Literal(':').suppress()
dot = Literal('.').suppress()

double_string = QuotedString('"', escChar='\\')
single_string = QuotedString("'", escChar='\\')
string = double_string | single_string

# Recursive identifier (i.e. a.b.c)
identifier = Word(alphas + '_', alphanums + '_')
identifier = identifier + ZeroOrMore(dot + identifier)

# term = string | identifier
term = Forward()
args = delimitedList(term) | Empty()

invocation = identifier + lparen + args + rparen
member_invocation = identifier + dot + invocation

term <<= (member_invocation | invocation | identifier | string)

expression = term
assignment = identifier + equals + expression

smake_line = assignment | expression

# Get type of the result
lines = [line for line in content.splitlines() if line.strip() != '']

for line in lines:
    print(line)
    print('\tparses to:', smake_line.parseString(line))
