#!/usr/bin/env python
import copy
import os
import pathlib
import platform
import colorama
import shlex

from colorama import Fore, Style

# Initialize colorama
colorama.init()

# Colors
class colors:
    if platform.system() == 'Windows':
        OKBLUE = Fore.BLUE
        OKCYAN = Fore.CYAN
        OKGREEN = Fore.GREEN
        WARNING = Fore.YELLOW
        FAIL = Fore.RED
        RESET = Style.RESET_ALL
        BOLD = Style.BRIGHT
    else:
        OKBLUE = '\033[94m'
        OKCYAN = '\033[96m'
        OKGREEN = '\033[92m'
        WARNING = '\033[93m'
        FAIL = '\033[91m'
        RESET = '\033[0m'
        BOLD = '\033[1m'

# Generate message
def message(type, color, message):
    return colors.BOLD + color + type + ': ' + colors.RESET + message

# Assert that a file exists
def assert_file(file_path):
    if not os.path.exists(file_path):
        msg = 'file ' + file_path + ' does not exist'
        print(message('fatal error', colors.FAIL, msg))
        exit(-1)

# Error exceptions
class InvalidInput(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return self.message

# Script class to encapsulate script and its options
class Script:
    def __init__(self, pathdir):
        self.commands = []
        self._cwd = pathdir
        self._pathdir = pathdir

    def set_cwd(self, cwd):
        self._cwd = os.path.join(self._pathdir, cwd)
        self._cwd = os.path.normpath(self._cwd)

    def __repr__(self):
        return 'Script {\n' \
            + '\tcommands: ' + str(self.commands) + '\n' \
            + '\tcwd: ' + str(self._cwd) + '\n' \
            + '}'

# Build and Target structures
class Build:
    DEFAULT_COMPILER = 'g++'

    def __init__(self, target, path):
        self.target = target
        self.path = path
        self.sources = []
        self.includes = []
        self.libraries = []
        self.flags = []
        self.macros = {}
        self.compiler = Build.DEFAULT_COMPILER

        # Fields to be filled by program
        self._cc_depenedencies = None
        self._cc_dir = None
        self._cc_includes = None
        self._cc_sources = None

    def define(self, macro_map):
        # Make sure macro_map is a dictionary
        if not isinstance(macro_map, dict):
            raise InvalidInput('macro_map must be a dictionary')

        # Make sure all keys are strings
        for key in macro_map.keys():
            if not isinstance(key, str):
                raise InvalidInput('macro_map keys must be strings')

        self.macros.update(macro_map)

    def set_compiler(self, compiler):
        self.compiler = compiler

    def add_sources(self, *sources):
        self.sources.extend(sources)

    def add_includes(self, *includes):
        self.includes.extend(includes)

    def add_libraries(self, *libraries):
        self.libraries.extend(libraries)

    def set_flags(self, flags):
        if isinstance(flags, list):
            # Dont split here...
            self.flags = flags
        else:
            self.flags = shlex.split(flags)

    def add_flags(self, flags):
        self.flags += ' ' + flags

class Target:
    all = {}

    def __init__(self, name, path):
        self.name = name
        self.path = path
        self.builds = {}

        # TODO: multiple post-builds and install scripts..
        self.post_builds = {}
        self.install_scripts = []

        # Add to all targets
        Target.all[name] = self

    def new_build(self):
        return Build(self, self.path)

    def add_build(self, build):
        mode = 'default'
        if isinstance(build, Build):
            pass
        elif isinstance(build, tuple) \
                and isinstance(build[0], str) \
                and isinstance(build[1], Build):
            mode = build[0]
            build = build[1]
        else:
            raise InvalidInput(
                'provided argument must be of' + \
                ' type Build or (str, Build)'
            )
        
        self.builds[mode] = build

    def add_builds(self, *builds):
        for build in builds:
            self.add_build(build)

    def set_post_build(self, script):
        mode = 'default'
        if isinstance(script, str):
            cmd = script
            script = Script(os.path.dirname(self.path))
            script.commands.append(cmd)
        elif isinstance(script, Script):
            pass
        elif isinstance(script, tuple) \
                and isinstance(script[0], str) \
                and isinstance(script[1], str):
            mode = script[0]
            cmd = script[1]
            script = Script(os.path.dirname(self.path))
            script.commands.append(cmd)
        elif isinstance(script, tuple) \
                and isinstance(script[0], str) \
                and isinstance(script[1], Script):
            mode = script[0]
            script = script[1]
        else:
            raise InvalidInput(
                'provided argument must be of' + \
                ' the forms: str, Script, (str, str), (str, Script)'
            )

        assert(isinstance(script, Script))
        self.post_builds[mode] = script
    
    def set_post_builds(self, *scripts):
        for script in scripts:
            self.set_post_build(script)

    def on_install(self, *scripts):
        self.install_scripts.extend(scripts)

import traceback

def evaluate_file(path):
    # All variables in a single evaluation context
    pathdir = os.path.dirname(path)

    variables = {
            'target': lambda name: Target(name, path),
            'script': lambda: Script(pathdir),
    }

    # Open the file
    file = open(path, 'r')
    content = file.read()

    try:
        compiled = compile(content, path, 'exec')
        exec(compiled, variables)
    except Exception as e:
        print(message('error', colors.FAIL, str(e)))
        traceback.print_tb(e.__traceback__)
        exit(-1)

# Read all .smake files from this directory or any subdirectory
smake_files = []
for root, dirs, files in os.walk('.'):
    path = root.split(os.sep)
    for file in files:
        if file.endswith('.smake'):
            smake_file = os.path.join(root, file)
            smake_files.append(smake_file)

for smake_file in smake_files:
    evaluate_file(smake_file)

def list_targets(targets):
    # Return if no targets
    if len(targets) == 0:
        return

    # Compute padding
    maxlen = 0
    for target in targets:
        if len(target) > maxlen:
            maxlen = len(target)

    maxlen += 5

    # Header message
    fmt = colors.BOLD + colors.OKCYAN + '{:<' + str(maxlen) + '}' \
        + colors.OKBLUE + '{}' + colors.RESET

    print(fmt.format('Target', 'Build modes'))

    # Print the targets
    for name in targets:
        target = targets[name]

        modes = list(target.builds.keys())
        modes = ', '.join(modes)

        fmt = colors.OKCYAN + '{:<' + str(maxlen) + '}' + \
            colors.OKBLUE + '{}' + colors.RESET
        print(fmt.format(target.name, modes))

list_targets(Target.all)

# TODO: error if no smake files found
import subprocess

# Preprocess a particular build configuration
#   There are quite a few issues when trying to cache
#   the dependencies. For example, we need to update the file
#   if the smake file changes, if the source file changes, if any
#   of the dependencies change, etc. This is a lot of work, and
#   it's not clear if it's worth it. For now, we skip caching
#   Maybe we can multithread this?
def preprocess_build(build):
    # TODO: expand sources (if regex) and make sure they exist
    build._cc_dir = os.path.dirname(build.path)
    fixed_sources = [os.path.join(build._cc_dir, source) for source in build.sources]

    sources = []
    for source in fixed_sources:
        p = pathlib.Path('.')
        glob = p.glob(source)
        for g in glob:
            # Skip if directory (no recursive globbing)
            if g.is_dir():
                continue

            # Get absolute path
            g = os.path.abspath(g)
            sources.append(str(g))

    cc_flat_sources = ' '.join(sources)

    # Compile all includes
    cc_includes = []
    for include in build.includes:
        include = os.path.join(build._cc_dir, include)
        include = os.path.abspath(include)
        cc_includes.append(include)

    cc_includes = ['-I' + include for include in cc_includes]
    cc_flags = build.flags

    # Dependency generation command
    cmd_dep = build.compiler + ' -MM ' + ' '.join(cc_includes) + ' ' + cc_flat_sources
    print(cmd_dep)

    dep_output = subprocess.check_output(cmd_dep, shell=True)

    # Parse the dependency output
    dep_output = dep_output.decode('utf-8')
    dep_output = dep_output.split()

    # Separate for each file
    dependency_set = set()
    dependency_list = []

    source_info = {}

    source_index, index = 0, 0
    while source_index < len(sources):
        source = sources[source_index]

        # Move to the next source
        expected = os.path.basename(source)
        expected = pathlib.Path(expected).stem + '.o'


        def loop_condition(index, expected):
            if expected is None:
                return True

            return (dep_output[index] != expected) and \
                (dep_output[index] != expected + ':')

        while (index < len(dep_output)) and loop_condition(index, expected):
            index += 1

        assert (dep_output[index] == expected) \
                or (dep_output[index] == expected + ':'), \
                'invalid dependency output'

        # Collect the dependencies
        index += 1 # Skip the colon

        next_expected = None
        if source_index < len(sources) - 1:
            next_expected = os.path.basename(sources[source_index + 1])
            next_expected = pathlib.Path(next_expected).stem + '.o'

        deps = []
        while (index < len(dep_output)) and loop_condition(index, next_expected):
            dep = dep_output[index]
            if dep != '\\' and dep != ':':
                dep = os.path.normpath(dep)

                if dep in dependency_set:
                    deps.append(dependency_list.index(dep))
                else:
                    deps.append(len(dependency_list))
                    dependency_set.add(dep)
                    dependency_list.append(dep)

            index += 1

        source_info[source] = deps
        source_index += 1

    # Forward information to the build object
    build._cc_includes = cc_includes
    build._cc_depenedencies = dependency_list
    build._cc_sources = source_info

# Get modification time for each dependency
def get_dependency_mtime(dependencies):
    dependency_mtime = []
    for dependency in dependencies:
        mtime = os.path.getmtime(dependency)
        dependency_mtime.append(mtime)

    return dependency_mtime

# Generate build commands
import hashlib

def generate_commands(build, mode):
    # Create the build directories
    # TODO: assist method
    smake_dir = os.path.join(build._cc_dir, '.smake')
    all_builds_dir = os.path.join(smake_dir, 'builds')

    build_name = build.target.name + '-' + mode

    build_dir = os.path.join(all_builds_dir, build_name)
    os.makedirs(build_dir, exist_ok=True)

    # Compilation commands
    command_map = {}
    hashed_sources = {}

    build_outputs = []
    for source in build._cc_sources:
        output = source.replace('/', '_') + '.o'

        # Hash each output to a shorter name
        m = hashlib.md5()
        m.update(output.encode('utf-8'))
        m = m.hexdigest()[:10]

        if m in hashed_sources:
            hashed_sources[m] += 1
        else:
            hashed_sources[m] = 1

        m += '{:04d}'.format(hashed_sources[m])

        output = m + '.o'
        output = os.path.join(build_dir, output)

        build_outputs.append(output)

        cmd_compile = [build.compiler, '-c', source, '-o', output]
        cmd_compile += build.flags
        cmd_compile += build._cc_includes

        for macro, value in build.macros.items():
            cmd_compile.append('-D' + macro + '=' + str(value))

        command_map[source] = (output, cmd_compile)

    # Linking command
    all_targets_dir = os.path.join(smake_dir, 'targets')
    os.makedirs(all_targets_dir, exist_ok=True)

    output = os.path.join(all_targets_dir, build.target.name)

    cmd_link = [build.compiler, '-o', output]
    cmd_link += build_outputs
    cmd_link += ['-l' + lib for lib in build.libraries]

    command_map['__link__'] = (output, cmd_link)

    return command_map, output

# Check if a file needs to be recompiled
def needs_recompile(build, source, source_out_mtime, dependency_mtime):
    for index in build._cc_sources[source]:
        if dependency_mtime[index] > source_out_mtime:
            return True
    
    return False

import multiprocessing

def __thread_init__(_lock, _counter, _total):
    global lock, counter, line, total

    lock = _lock
    counter = _counter
    total = _total

import shutil

def compile_source(build, dependency_mtime, source, output, cmd_compile):
    global counter, total

    source_out_mtime = 0
    if os.path.exists(output):
        source_out_mtime = os.path.getmtime(output)

    recompile = needs_recompile(build, source, source_out_mtime, dependency_mtime)

    if not recompile:
        with counter.get_lock():
            size = shutil.get_terminal_size()
            print(' ' * size.columns, end='\r')
            msg = colors.BOLD + f'[{counter.value}/{total}]' + colors.RESET
            msg += f' {source} '
            msg += colors.OKBLUE + '(up to date)' + colors.RESET
            print(msg, end='\r')
            counter.value += 1
        return source

    proc = subprocess.Popen(cmd_compile, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    proc.wait()
    out, err = proc.communicate()

    with counter.get_lock():
        out = out.decode('utf-8')
        err = err.decode('utf-8')

        spaced = False
        if out != None and len(out) > 0:
            print('\n')
            spaced = True
            print(out)

        if err != None and len(err) > 0:
            if not spaced:
                print('\n')
            print(err)

        if proc.returncode != 0:
            size = shutil.get_terminal_size()
            print(' ' * size.columns, end='\r')
            msg = colors.BOLD + f'[{counter.value}/{total}]' + colors.RESET
            msg += f' {source} '
            msg += colors.FAIL + '(failed)' + colors.RESET
            print(msg, end='\r')
            counter.value += 1
            return None

        size = shutil.get_terminal_size()
        print(' ' * size.columns, end='\r')
        msg = colors.BOLD + f'[{counter.value}/{total}]' + colors.RESET
        msg += f' {source} '
        msg += colors.OKGREEN + '(success)' + colors.RESET
        print(msg, end='\r')
        counter.value += 1
        return source

def build_target(target, mode, threads=16):
    build = target.builds[mode]
    preprocess_build(build)

    command_map, output = generate_commands(build, mode)

    dependency_mtime = get_dependency_mtime(build._cc_depenedencies)

    args = []
    for source in command_map:
        if source == '__link__':
            continue

        output, cmd_compile = command_map[source]
        print(cmd_compile)
        args.append((build, dependency_mtime, source, output, cmd_compile))

    counter = multiprocessing.Value('i', 1)
    with multiprocessing.Pool(threads,
                initializer=__thread_init__,
                initargs=(multiprocessing.Lock(), counter, len(args))
            ) as pool:
        rets = pool.starmap(compile_source, args)

    # Gather failed sources
    # TODO: method
    source_indexed = command_map.copy()
    source_indexed.pop('__link__')
    source_indexed = list(source_indexed.keys())

    failures = []
    for i in range(len(rets)):
        if rets[i] == None:
            failures.append(source_indexed[i])

    if len(failures) > 0:
        size = shutil.get_terminal_size()
        print('\n')
        print(' ' * size.columns, end='\r')
        msg = 'Failed to compile the following sources:'
        print(message('error', colors.FAIL, msg))
        for failure in failures:
            print('\t', failure)
        return
    else:
        size = shutil.get_terminal_size()
        print('\n')
        print(' ' * size.columns, end='\r')
        msg = 'All sources compiled successfully'
        print(message('success', colors.OKGREEN, msg))

    # Linking
    # TODO: method
    output, cmd_link = command_map['__link__']
    proc = subprocess.Popen(cmd_link, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    proc.wait()
    out, err = proc.communicate()

    if out != None and len(out) > 0:
        print(out.decode('utf-8'))

    if err != None and len(err) > 0:
        print(err.decode('utf-8'))

    if proc.returncode != 0:
        msg = 'Failed to link the target ' + target.name + ' in mode ' + mode
        print(message('error', colors.FAIL, msg))
        return
    else:
        msg = 'Target ' + target.name + ' in mode ' + mode + ' linked successfully'
        print(message('success', colors.OKGREEN, msg))

    if mode in target.post_builds:
        script_variables = {
            'SMAKE_TARGET': os.path.abspath(output),
        }

        script = target.post_builds[mode]
        if len(script.commands) == 0:
            msg = 'No commands specified in the post-build script'
            print(message('warning', colors.WARNING, msg))
            return

        for var in script_variables:
            for i in range(len(script.commands)):
                cmd = script.commands[i]
                script.commands[i] = cmd.replace('$' + var, script_variables[var])

        msg = 'Running post-build script for target ' + target.name + ' in mode ' + mode
        print(message('info', colors.OKBLUE, msg))
        for cmd in script.commands:
            print(message('exec', colors.OKCYAN, cmd))
            subprocess.call(cmd, shell=True, cwd=script._cwd)

import argparse

argparser = argparse.ArgumentParser()
argparser.add_argument('target', help='The target to build')
argparser.add_argument('-m', "--mode", help="Execution mode", default='default')

args = argparser.parse_args()

print('args:', args)

build_target(Target.all[args.target], args.mode)

# Use python to run this file itself?
